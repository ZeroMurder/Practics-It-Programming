═══════════════════════════════════════════════════════════════════════════════
                    ОБЪЯСНЕНИЕ КОДА ДЛЯ ПРАКТИКИ - ИНТЕРНЕТ-МАГАЗИН
═══════════════════════════════════════════════════════════════════════════════

## НАЗНАЧЕНИЕ ПРОГРАММЫ
Код создает полноценную SQLite базу данных интернет-магазина с 4 связанными таблицами:
- Users (пользователи)
- Products (товары) 
- Orders (заказы)
- OrderItems (товары в заказах)

Демонстрирует полный цикл: создание таблиц → заполнение данными → сложный аналитический SQL-запрос.

## СТРУКТУРА БАЗЫ ДАННЫХ

┌─────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│     Users       │1───┤     Orders       │1───┤    OrderItems    │
│ id (PK)         │    │ id (PK)          │    │ id (PK)          │
│ email (UNIQUE)  │    │ user_id (FK)     │    │ order_id (FK)    │
│ password_hash   │    │ status           │    │ product_id (FK)  │
│ full_name       │    │ total_amount     │    │ quantity         │
│ created_at      │    │ order_date       │    │ price_at_order   │
└─────────────────┘    └──────────────────┘    └──────────────────┘
                              │
                       ┌──────────────────┐
                       │    Products      │
                       │ id (PK)          │
                       │ name             │
                       │ description      │
                       │ price (CHECK>0)  │
                       │ stock_quantity   │
                       └──────────────────┘

## ПОСЛЕДОВАТЕЛЬНОСТЬ РАБОТЫ КОДА

1. ИМПОРТЫ
===========
import sqlite3     # Работа с SQLite
import os          # Работа с файлами/папками
from datetime import datetime  # Даты

2. СОЗДАНИЕ БАЗЫ
================
db_path = os.path.join(os.getcwd(), 'shop.db')
conn = sqlite3.connect(db_path)
conn.execute("PRAGMA foreign_keys = ON")  # ← ВАЖНО: включает внешние ключи

3. СОЗДАНИЕ ТАБЛИЦ (CREATE TABLE IF NOT EXISTS)
==============================================
✓ Users: email UNIQUE, created_at по умолчанию
✓ Products: price>0, stock_quantity>=0 (CHECK ограничения)
✓ Orders: user_id ссылается на Users(id)
✓ OrderItems: order_id→Orders, product_id→Products

4. ЗАПОЛНЕНИЕ ДАННЫМИ (INSERT OR IGNORE)
=======================================
Пользователь: user@test.ru "Иван Иванов"
Товары: iPhone 15 (50к₽, 10шт), Футболка (1к₽, 50шт)
Заказ #1: iPhone(1шт) + Футболки(10шт) = 51,000₽ (статус PAID)

5. ГЛАВНЫЙ SQL-ЗАПРОС (АНАЛИТИКА)
================================
SELECT o.id, o.order_date, o.status,
       COUNT(oi.id) AS items_count,        ← количество позиций
       SUM(oi.quantity * oi.price_at_order) AS total_sum  ← итоговая сумма
FROM Orders o LEFT JOIN OrderItems oi ON o.id = oi.order_id
WHERE o.user_id = 1
GROUP BY o.id ORDER BY o.order_date DESC

ЛОГИКА:
- LEFT JOIN = все заказы пользователя + их товары
- COUNT = считает товары в заказе
- SUM пересчитывает сумму по ценам НА МОМЕНТ ЗАКАЗА
- GROUP BY o.id = группирует по заказам

РЕЗУЛЬТАТ:
Заказ #1 | 2026-01-19 | PAID | 2 товаров | 51,000₽

## КЛЮЧЕВЫЕ ТЕХНИЧЕСКИЕ РЕШЕНИЯ

✅ ОБРАБОТКА ОШИБOK
try-except-finally + conn.close() в любом случае

✅ ИДИМПОТЕНЦИАЛЬНОСТЬ
CREATE TABLE IF NOT EXISTS + INSERT OR IGNORE = можно запускать много раз

✅ ЦЕЛОСТНОСТЬ ДАННЫХ
PRAGMA foreign_keys=ON + CHECK ограничения + FOREIGN KEY

✅ АБСОЛЮТНЫЙ ПУТЬ
os.path.join(os.getcwd(), 'shop.db') = файл создается в текущей папке

## ДЛЯ ОТЧЕТА ПО ПРАКТИКЕ ГОВОРИМ:

"Разработал реляционную БД интернет-магазина на SQLite с 4 таблицами и каскадными связями.
Реализовал аналитический запрос с LEFT JOIN, агрегацией COUNT/SUM и сортировкой.
Обеспечил целостность данных через FOREIGN KEY constraints и CHECK ограничения.
Применил обработку ошибок и идемпотентность для безопасного повторного выполнения."

═══════════════════════════════════════════════════════════════════════════════
                    ФАЙЛ shop.db СОЗДАН УСПЕШНО (~12КБ)
═══════════════════════════════════════════════════════════════════════════════
